# DIP-Fantasy

BIT数字图像处理大作业。试图运用大三上所学的所有新技术来完成(最后并没有运用到所有新技术X)。总而言之,是一个使用传统方法的车道线检测任务

目前准确率可达0.705，已知的相同方法进行优化后准确率可达到0.85

最后并没用原本的方法，在实践的过程中，发现一个更简单的方法效果效果更好：

颜色切割 -> 边界提取 -> 霍夫变换

其中最重要的部分是如何在`颜色切割`处获得较为纯净的车道线

## 项目结构

项目的`tree`:

```shell
.
├── backup
│   └── 课堂内容实现
├── build
│   └── CMakeFiles
├── doc
├── input
│   └── DataSet
├── judge
└── lib
    └── debug
```

- `/build`为放置CMake临时文件的目录，并不重要。一个众所周知的用法是：

  ```shell
  cd ./build
  cmake ..
  ```

- `/doc`放置了本项目的文档，包括OpenCV以及其他相关软件（如CMake）的使用
- `/input`存放了输入图片的数据集.因为训练集中的图片较多，体积比较大，因此将其全部存放在了本地的`/input/DataSet`中而不是上传到Github
- `/judge`部分放了评测机。如何使用评测请看后文
- `/lib`文件夹即为`DipFantasy.h`和其对应的源文件的代码，也就是本项目所试图构建的图形库。根目录的`Main.cpp`通过调用这个库完成流程
- `/backup`为其他实现方法的Main函数
  - `/backup/课堂内容实现`为练手部分，通过调用OpenCV实现了课堂中所要求的部分

### 运行模块

`./DipFantasy`为本项目的可执行文件。从命令行的第一个参数读入图像的路径，输出检测到的直线的极坐标

`./get_predict_json.py`可生成`predict.json`，调用并运行`./DipFantasy`，向其输入数据集的图片的路径并通过它的输出画出检测到直线的json格式的数据

`./judge/lane.py`为评测机，通过对比`./judge/groundtruth.json`和`./judge/predict.json`获得跑分结果

## 如何运行本项目

这里有一个一键完成编译+运行+跑分的脚本，如果你使用的是Linux，那么使用这个脚本可以很快的看到本项目运行的结果。

项目的根目录中有`/compile_and_judge.sh`

终端输入

```shell
bash ./compile_and_judge.sh
```

或者直接输入:

```shell
./compile_and_judge.sh
```

即可完成项目的编译+跑分

## 编译方法

```shell
cmake .
make
```

如果要清除编译后的缓存，使用vscode的任务clean即可。

### Debug

模块Debug：在`/lib`下有一个`/lib/debug`文件，里面装了单独编译`lib/DipFantasy.cpp`的`CMake`文件。将`DipFantasy.cpp`的main注释解除，再将vscode的调试选项设置为`module debug`就能单独调试库函数（直接在`ib/DipFantasy.cpp`中调试）。

## 流程

滤波平滑->阈值->sobel/canny后的结果和蒙板相乘->霍夫变换->得到对应检测的线的参数

![image-20210201213204319](https://cdn.jsdelivr.net/gh/I-Rinka/picTure//image-20210201213204319.png)

其中构造蒙板可以使用RGB或HSI的方法扣出车道线

最后放弃使用了相乘，而是直接对扣象后所得的蒙板sobel，这样效果更好。

## 如何评测

评测机为`lane.py`，来自 <https://github.com/TuSimple/tusimple-benchmark> 中的车道线评测机`lane.py`

将**对应格式**的评测结果输出成`./predict.json`后，在shell中输入命令就能进行跑分：

```shell
python3 ./lane.py ./predict.json ./groundtruth.json
```

注意，上面所说的`predict.json`的格式比原来要多加一项`"run_time":`属性以表示处理每一帧所用的时间。因为我们的评测只有一帧图片，并且运行时间对我们来说无关紧要，所以设置为`0`即可。上述格式输出的`predict.json`文件中的每一行的格式应该和这个类似（注意多添加一个`"run_time"=0`）：

### 评测格式说明

我们需要通过自己写的程序生成一个`predict.json`，并用这个文件和`groundtruth.json`进行对比，最后得到跑分的结果。

`predict.json`一行的示例如下：

```json
{"lanes": [[-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 610, 600, 590, 580, 570, 560, 550, 540, 530, 520, 510, 500, 490, 480, 470, 460, 450, 440, 430, 420, 410, 400, 390, 380, 370, 360, 350, 340, 330, 320, 310, 300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190, 180, -2], [-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 686, 699, 711, 724, 736, 748, 761, 773, 786, 798, 810, 823, 835, 848, 860, 872, 885, 897, 909, 922, 934, 947, 959, 971, 984, 996, 1009, 1021, 1033, 1046, 1058, 1071, 1083, 1095, 1108, 1120, 1133, 1145, 1157, 1170, 1182, 1195, 1207, 1219, 1232], [-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 755, 794, 832, 869, 904, 938, 973, 1007, 1042, 1076, 1111, 1145, 1180, 1214, 1249, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2]], "h_samples": [160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710],"raw_file": "clips/0530/1492626409999627292_0/20.jpg","run_time":0}
```

- `"lanes"`是一个二维数组,第一个维度代表了直线的数量,第二个维度中的值表示了直线的横坐标
- `"h_samples"`表示了直线的纵坐标
- `"raw_file"`表示了图像文件的路径
- `"run_time"`表示处理这个图像花费的时间

这个评测使用的是线性回归，并且测试的是相似性，因此并不要求输出结果完全点对点。即使参数上有一点小波动，甚至是少检测出一根线，都不会有非常非常大的影响。

由于评测机是python2的格式，和python3不兼容。为了方便，我将文件中的`print`改为了python3的`print()`格式，其余部分未进行改动

## 进度

- [x] 预处理
  - [x] 图像读入
  - [x] 高斯滤波
  - [x] 颜色切割
  - [x] 直方图均衡（彩色，三通道）
- [x] 梯度运算
  - [x] sobel
  - [ ] sobel单线化（舍弃右边，只要左边）
- [x] 后处理
  - [x] 乘法（图像屏蔽）
  - [x] 加法（构造mask）
  - [X] 形态学运算
- [x] 霍夫变换
- [x] 直线筛选

整体流程：

- [x] 造库
- [X] 编程
- [x] 评测机研究
  - [X] 多线程跑分
- [ ] 实验报告

希望弄懂的：

- [ ] Cpp向上、向下造型

## 结果

不同种方法的跑分差异:

```shell
单纯sobel: [{"name":"Accuracy","value":0.28955357142857147,"order":"desc"},{"name":"FP","value":0.435,"order":"asc"},{"name":"FN","value":0.9475,"order":"asc"}]
我的方法,单优化: [{"name":"Accuracy","value":0.3197321428571428,"order":"desc"},{"name":"FP","value":0.43666666666666665,"order":"asc"},{"name":"FN","value":0.95,"order":"asc"}]
我的方法,双优化: [{"name":"Accuracy","value":0.439642857142857,"order":"desc"},{"name":"FP","value":0.9416666666666668,"order":"asc"},{"name":"FN","value":0.9558333333333334,"order":"asc"}]
骨架法,双优化: [{"name":"Accuracy","value":0.42885416666666687,"order":"desc"},{"name":"FP","value":0.9241666666666667,"order":"asc"},{"name":"FN","value":0.9516666666666667,"order":"asc"}]
我的方法,固定输出四个直线: [{"name":"Accuracy","value":0.5230208333333332,"order":"desc"},{"name":"FP","value":0.9425,"order":"asc"},{"name":"FN","value":0.9366666666666669,"order":"asc"}]
我的方法，黄色使用HSI切割，同时白色使用动态取值：[{"name":"Accuracy","value":0.6231101190476191,"order":"desc"},{"name":"FP","value":0.7075,"order":"asc"},{"name":"FN","value":0.6641666666666665,"order":"asc"}]
目前结果：[{"name":"Accuracy","value":0.6921279761904764,"order":"desc"},{"name":"FP","value":0.57,"order":"asc"},{"name":"FN","value":0.5066666666666668,"order":"asc"}]
加上闭运算：[{"name":"Accuracy","value":0.6931994047619051,"order":"desc"},{"name":"FP","value":0.5625,"order":"asc"},{"name":"FN","value":0.4958333333333333,"order":"asc"}]
边界提取：[{"name":"Accuracy","value":0.7058035714285714,"order":"desc"},{"name":"FP","value":0.5525,"order":"asc"},{"name":"FN","value":0.48750000000000004,"order":"asc"}]
```
